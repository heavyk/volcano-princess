# YueJit

### 2023-11-26 20:07 - initial thoughts

today I felt like I wanted to look at my email, and actually to my surprise, jin had emailed me back -- and quite positively too. I blelive I had checked my email at least once since I sent out the email, but apparently I hadn't; and it'd already been 8 days since then. I'm actually quite surprised. I don't feel any problems about the delayed response on my part, but I did notice quite a few changes that have happened in the last 30m since I read her reply... they are the following: I tuned into her, and I notice that my brain no longer feels the same surity that I normally have -- like, for example she said about "beating" LuaJIT (or just doing it for fun) -- but I thought in full seriousness, "I don't think I can beat mike (pall)". his code is like really good, and he knows like really a lot more about microprocessors than I do (and stuff). I really don't consider myself to be a super duper programmer in any way. I just know I can figure stuff out and am confident in that -- and that's the main thing that's left me the last few minutes or so. I'll prolly get it back pretty soon, so it's no worries, but instead I'm saying this to express the reality of my nature, which is to reflect the people that I'm coming into contact with.
    you know, this is a question that I've had the last few months or so (since I started playing chinese games, starting with volcano-princess and immortal-mayor), which is why -- if these things that most of us struggle at come so effortless to them, like skinning and animating hundreds of models or writing incredibly complicated code (as if they see the whole codebase at once) -- why don't they just take over the world or something -- like they have all the skills, technology, and everything that they would need to fully make everything a reflection of their creativity, yet they just stick to making simple microwave ovens and stuff like that. it seems to me like they can catch on to patterns really easily and replicate them, so why aren't they reflecting western culture and trying to become dominant? why not just replicate western ideas and do them better and cheaper than westerners can.
        (before I write my hypothesis) personally, for me, I have to say that I constantly struggle with becoming a reflection of western ideas. I grew up with machineguns and g.i. joes, but that faded the more I found out about technology and all the cool stuff that can be done with it. because I'm american though, all of my desire to create better and easier to use things, appears (because of the reflection) like I'm constantly wanting to take over the world -- as if I'm scheming to become dominant, when in fact I want nothing of domination; I only like that things go easy and smoothe, so often times in my efforts to have things go easier, it appears that I'm dictating how it should be (this makes me look a bit bossy to others, I've noticed). I live in a very symbolic society, and it's hard for them to conceive that I just want to make cool stuff, as they're all looking from the mutual-back-scratching perspective where I have an ulterior motive to what I'm doing, to get some kind of personal benefit for myself (I am pretty selfish). it created a struggle at first, because I didn't want to *appear* like they did being selfish, so I would refrain from doing anything that would give the *appearance* to anyone that I'm selfish. I got over that eventually though and now I'm fine being fully selfish, because I actually like me more than they like theirselves. what I'm saying is, a lot of western ideals (even the questionable ones) are actually not all that bad at all when pictured from a creativity and desire perspective. as an example, if I were to do something for someone else (something that's considered "good"), I'm usually hindering them by making them feel better when it's their job to make them feel better, not mine. we have a lot of social expectations that strongly disempower everyone -- like for example titles, and age minimums, and other prerequisites and conditions which we say must be met before something (conditionals). our society runs like a computer program, but the "bad-guys", don't follow the rules though -- they do what they want to do, which is often times outside of the rules and conditions (bad), so it's looked down upon to actually "break the rules" -- but that's a false dialectic to begin with, because I'm not "breaking the rules" if I'm doing what I want to do -- because what I want to do (from a creativity/desire perspective) is actually in the highest/greatest good of everyone else, too (pure-desire always is). so I tend to embrace a whole lot of what the west views as "bad" and actually kinda shun the stuff they think is "good".
    what I believe is happening with the chinese actually is a serious case of "not good enough" -- and it's because of a lack of identity. symbolic people -- and the more symbolic they are -- are very *notable and defined*; they have an identity to them which makes them unique and different from the rest. each one of us is a character in the play, and the play wouldn't be any good if everyone looked the same, sounded the same, played all the same 4-5 parts, etc. -- so that lack of identity manifests itself as not-good-enoughness, because I'm not all that different from the next guy, and (s)he isn't doing that cool thing either -- cept the kings and rulers, because they look different, because they have a symbolic status and presense about them that says they're different. (that's probably a good way to summarise the feeling I wrote about earlier when I had my doubts about beating mike, actually).
I'm actually quite excited to begin this venture of making YueJIT, because I'm going to kinda like absorb their culture in all ways, and it'll make an amalgamation of me, but coming from the perspective of their culture. I anticipate many more moments when I'm suddenly thinking about things from a perspective that is not my own, and I'll find a way to get back to my "usual" way of thinking, which is very selfish, egotistical, and quite optimistic. it's going to be really fun. bye for now! I'm gonna go recover my ego and figure this next part out :) happy reflections!

### 2023-11-27 23:48 - some thoughts on the technology

since we'll be writing a new JIT from the beginning, I have some ideas:
1. I'm not 100% convinced that a stack-based VM is the way to go. it is the way that lua is programmed though, so going away from the stack model would mean invalidating a lot of existing libraries written for lua (unless of course a compatibility layer is created -- which is possible).
2. for this language, I want to make a lot of assumptions, and the number one of it is that the type of a function return can only be a type or nil; so, for example I can't have a function that returns a number sometimes and a string in another case. it's possible to allow multiple type returns sometime in the future, but it's considerably more work, because I want all code that goes into the VM to have a type assumed -- meaning that all functions actually have their types, so if there are (for example) floor(float), floor(int) functions extant, and I call floor with a string, then it'll produce a sort of "stub" function which converts the string to an int/float and then jumps to the appropriate type function. if (for example) the floor function returns a float and the code that called the function is expecting an int, then again, there's another tiny stub function which does the conversion before returning to the call site. the whole point is to make assumptions about the type, and then later (in some performance things we build), we can alert the programmer to any unnecessary conversions. machine code can be generated which will run at native speeds if all of the types can be resolved.
3. I don't want to use the interpretter ever, which means that any code input into the VM will get compiled as soon as it's received. in the compilation phase where the types are not known, the code will call the safe stubs which are type agnostic, until the type is figured out, and then after the type is found out (only needs to run once), the jump/call address will be updated to point to the function with the correct type. the drawback to this method is that multiple overload functions (with different input/output types) can exist in memory, and if the function is a large functon, then it could take a while to compile the functon before calling it (though not really a big problem). I also want to give the programmer the ability to see how many different versions of the same function exist at any given time, so they can optimise their types to reduce memory, and produce code that runs at native speeds.
4. I do want to give the programmer the ability to set the type in code so that a compiler can check the code symantically and give early errors (probably something the editor runs), and those hints will inform the JIT how to compile the function right away to the correct type, without having to wait for the "wrong" type to be found. I personally don't really like writing types, especially when they're obvious, and I think it's fine to pay a small penalty when the type isn't obvious, by having to compile the generic version of the function, then run through it updating the jump/call pointers and compiling the function again in its fully-typed form. it's a small price to pay which only has to be paid once.
5. I know this sounds counter-intuitive, but I (personally) don't really want to work right away on the VM, and instead I want to focus on the language in the form of an editor, because I want to move away from a 1d (text) language, and make it more dimensions than just a sequence. I imagine the sourcecode for a large project looking something akin to a large map in a 2d game (like imagine zelda or something), and I navigate the code by zooming in on certain items, selecting them, modifying some thing (or its code directly), and then moving out -- so in a sense, I want the editor for the program to become a part of the program. I want anyone (who wants to), to be able to open up the code and see the map of all of the parts -- and it'll look the "default" way (whatever the executable/dll has set) if the programmer doesn't have a preference; however, if the programmer prefers certain bytecode patterns to be displayed a certain way (or has a custom map-builder built for their easy navigation of the code), then the code will look to their preference. the ability to give each project its own "look" of color and style for how the code is presented, will gives each executable its own personaliity. I want to make moving and sharing code between each executable easy, and also there needs to be a standard way of serializing the code to text so that scms can see updates.
6. at the beginning of the project, I don't want to worry about PE/ELF/COFF headers, or anything like that, so I want all functions to be able to be output to ansi c, meaning that once a script/program is run (like YueJIT itself), then a .c file can be output which contains all of the functions (including the stubs) put into a single .c file which can then be compiled by gcc to build a native executable. in addition to that, this will serve greatly in the process of producing performant machine code, because the compiler's output can be compared with the JIT, and then improved. it'd also be super cool, if other language outputs were contributed in the future as well, so it could output rust, js, c#, etc. in addition to lua and c.
7. further into the future, I'd like to make it possible for a number of of the different functions and bytecode patterns to have a sort of collective repository, and that repository will be hash-based, where the hash of the bytecode (excluding metadata) is the hash, which means that code can be shared, and precompiled versions of functions can also exist, removing eventually the need for even the JIT compiler (instead it's just downloading the JIT code from another node in the distributed network). the whole point of using lua to do this project is that everything is a hash table, so even computation on this distributed network will run at native speeds, all using hash tables, which may or may not even exist on the local machine (but that's for a future when microprocessors are everywhere, and all things are connected to each other through simple LANs (party-LAN) so a few decades off, I imagine). this project is built around the idea that all functions will have an hash id and so therefore now all of the logical aspect (not just the data) is going to be going to be hashed. there's a lot of room for expansion for the veracity for both code and data using these hash functions (obviously the easiest one is when the bytecode's hash doesn't match the hash requested, throw the chunk out, because an io error occured somewhere -- or something malicious). lots of stuff to think about here.
